name: Build & Sign Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build-and-sign:
    runs-on: windows-latest
    
    permissions:
      contents: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.13'
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      - name: Clean build directories
        run: |
          if (Test-Path dist) { Remove-Item -Recurse -Force dist }
          if (Test-Path build) { Remove-Item -Recurse -Force build }
        shell: powershell
      
      - name: Check GitHub Secrets
        env:
          CERT_BASE64: ${{ secrets.CODE_SIGNING_CERT }}
          CERT_PASSWORD: ${{ secrets.CODE_SIGNING_PASSWORD }}
        run: |
          Write-Host "=== GitHub Secrets Verification ===" -ForegroundColor Cyan
          Write-Host ""
          
          # Check if CODE_SIGNING_CERT exists
          if ([string]::IsNullOrEmpty($env:CERT_BASE64)) {
            Write-Error "CODE_SIGNING_CERT secret is NOT set in GitHub repository settings!"
            Write-Host "Please add it in: Settings -> Secrets and variables -> Actions"
            exit 1
          }
          Write-Host "[OK] CODE_SIGNING_CERT found (length: $($env:CERT_BASE64.Length) chars)" -ForegroundColor Green
          
          # Check if CODE_SIGNING_PASSWORD exists
          if ([string]::IsNullOrEmpty($env:CERT_PASSWORD)) {
            Write-Error "CODE_SIGNING_PASSWORD secret is NOT set!"
            Write-Host "Please add it in: Settings -> Secrets and variables -> Actions"
            exit 1
          }
          Write-Host "[OK] CODE_SIGNING_PASSWORD found" -ForegroundColor Green
          Write-Host ""
        shell: powershell
      
      - name: Decode certificate from Base64
        env:
          CERT_BASE64: ${{ secrets.CODE_SIGNING_CERT }}
        run: |
          Write-Host "Decoding certificate from Base64..."
          try {
            $certBytes = [System.Convert]::FromBase64String($env:CERT_BASE64)
            [System.IO.File]::WriteAllBytes("CodeSigningCert.pfx", $certBytes)
            $fileSize = (Get-Item CodeSigningCert.pfx).Length
            Write-Host "[OK] Certificate decoded successfully (size: $fileSize bytes)" -ForegroundColor Green
          } catch {
            Write-Error "Failed to decode Base64 certificate: $($_.Exception.Message)"
            Write-Host "The Base64 string may be corrupted. Please re-encode and update the secret."
            exit 1
          }
        shell: powershell
      
      - name: Verify certificate file
        env:
          CERT_PASSWORD: ${{ secrets.CODE_SIGNING_PASSWORD }}
        run: |
          Write-Host "Verifying certificate with password..."
          try {
            $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2("CodeSigningCert.pfx", $env:CERT_PASSWORD)
            Write-Host "[OK] Certificate loaded successfully!" -ForegroundColor Green
            Write-Host "  Subject: $($cert.Subject)"
            Write-Host "  Thumbprint: $($cert.Thumbprint)"
            Write-Host "  Valid from: $($cert.NotBefore)"
            Write-Host "  Valid until: $($cert.NotAfter)"
          } catch {
            Write-Error "Failed to load certificate: $($_.Exception.Message)"
            Write-Host ""
            Write-Host "Possible causes:" -ForegroundColor Yellow
            Write-Host "  1. CODE_SIGNING_PASSWORD secret is incorrect"
            Write-Host "  2. PFX file is corrupted during Base64 encoding/decoding"
            Write-Host "  3. Certificate file and password do not match"
            exit 1
          }
        shell: powershell
      
      - name: Build executable with PyInstaller
        run: |
          python -m PyInstaller my_notepad_app.spec --clean
        shell: powershell
      
      - name: Sign executable
        env:
          CERT_PASSWORD: ${{ secrets.CODE_SIGNING_PASSWORD }}
        run: |
          $signtool = "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\x64\signtool.exe"
          
          # Fallback to other possible locations
          if (-not (Test-Path $signtool)) {
            $found = Get-ChildItem "C:\Program Files (x86)\Windows Kits" -Recurse -Filter "signtool.exe" -ErrorAction SilentlyContinue | 
                     Where-Object { $_.FullName -match "x64" } | 
                     Select-Object -First 1
            
            if ($found) {
              $signtool = $found.FullName
            } else {
              Write-Error "signtool.exe not found. Windows SDK must be installed."
              exit 1
            }
          }
          
          Write-Host "Signing with: $signtool"
          $password = $env:CERT_PASSWORD
          & $signtool sign /f "CodeSigningCert.pfx" /p $password /t "http://timestamp.sectigo.com/authenticode" /fd SHA256 /v "dist\my_notepad_app.exe"
          
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Failed to sign executable"
            exit 1
          }
          
          Write-Host "[OK] Successfully signed executable"
        shell: powershell
      
      - name: Verify signature
        run: |
          Write-Host "Verifying signature (self-signed cert warnings are expected)..."
          $signtool = "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\x64\signtool.exe"
          
          if (-not (Test-Path $signtool)) {
            $found = Get-ChildItem "C:\Program Files (x86)\Windows Kits" -Recurse -Filter "signtool.exe" -ErrorAction SilentlyContinue | 
                     Where-Object { $_.FullName -match "x64" } | 
                     Select-Object -First 1
            if ($found) { $signtool = $found.FullName }
          }
          
          & $signtool verify /pa /v dist\my_notepad_app.exe
          
          # Self-signed certificates will always fail /pa verification
          # Check if signature exists at all
          if ($LASTEXITCODE -eq 0) {
            Write-Host "[OK] Signature verified (trusted root)" -ForegroundColor Green
          } else {
            Write-Host "[INFO] Signature exists but uses self-signed certificate (expected)" -ForegroundColor Yellow
            Write-Host "The executable IS signed, but the certificate is not in the trusted root store."
          }
        shell: powershell
        continue-on-error: true
      
      - name: Get file info
        id: file-info
        run: |
          $file = Get-Item dist\my_notepad_app.exe
          $size = [math]::Round($file.Length / 1MB, 2)
          "size=$size MB" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "filename=$($file.Name)" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        shell: powershell
      
      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref }}
          name: Release ${{ github.ref_name }}
          body: |
            ## Pro Multi-Tab Notepad ${{ github.ref_name }}
            
            ### Downloads
            - Signed Executable: my_notepad_app.exe (${{ steps.file-info.outputs.size }})
            
            ### Features
            - [OK] Code Signed (Self-Signed Certificate)
            - [OK] Timestamp Authority Verified
            - [OK] Ready to distribute
            
            ### Installation
            1. Download my_notepad_app.exe
            2. Run the executable
            3. No installation required!
            
            ### Security
            - This release is digitally signed with a self-signed certificate
            - Signature verified by Sectigo timestamp authority
            - Safe to distribute
          files: |
            dist/my_notepad_app.exe
          draft: false
          prerelease: false
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Clean up certificate
        if: always()
        run: |
          if (Test-Path CodeSigningCert.pfx) {
            Remove-Item CodeSigningCert.pfx -Force
          }
        shell: powershell